netsh int ipv4 show excludedportrange protocol=tcp
netsh int ipv4 set dynamic tcp start=49152 num=16384
docker run --name oracle11g --privileged -d -p 1521:1521 jaspeen/oracle-xe-11g
docker exec -it oracle11g bash



docker run --name myoracle --hostname myoracle -itd --network=mybridge --ip 10.10.10.196 -p 1521:1521 -p 5500:5500 -p 8080:8080 -e ORACLE_ENABLE_XDB=true -e ORACLE_ALLOW_REMOTE=true -e ORACLE_DISABLE_ASYNCH_IO=true -v D:\docker\uway1:/local andyrbell/oracle-xe-11g-centos

vi ~/.bash_profile
alias sqlplus='/u01/app/oracle/product/11.2.0/xe/bin/sqlplus'
. ~/.bash_profile




sqlplus로 접속 해 봅니다. 초기 관리자 ID 와 PW는 system / oracle 입니다.
보안을 위해 바로 password 를 입력해 비밀번호를 변경 해 줍니다.
유저 생성 : CREATE USER [유저이름] IDENTIFIED BY [비밀번호];
권한부여 : GRANT [권한] TO [대상유저];
GRANT RESOURCE, CONNECT TO [대상유저]
grant create view to [대상유저]

cd $ORACLE_HOME
sqlplus / as sysdba
username : sys as sysdba
passoword: oracle
GRANT EXECUTE ON SYS.utl_file TO uway;
create directory DIR_TEMP as '/tmp';
grant read, write on directory DIR_TEMP to uway;


connect "/ as sysdba"

-- startup mount exclusive


-- alter database character set KO16MSWIN949;

shutdown immediate;

startup restrict;

alter system enable restricted session;
-- alter database character set INTERNAL_USE KO16MSWIN949;
alter database character set KO16MSWIN949;
alter database NATIONAL character set KO16KSC5601;

shutdown;

startup



암호 기간 만료 비활성화
; alter profile default limit password_life_time unlimited;
최대 접속 가능 process 조회 및 변경
; show parameter processes;
; alter system
; set processes = 200 scope=spfile;


show parameter audit;
alter system set audit_trail=db, extended scope=spfile sid='*';

alter system set audit_trail=db, extended

; 서버 재기동

shutdown immediate
startup


audit select table, insert table, update table, delete table by IPSI;
audit table, alter table by IPSI;

audit select table, insert table, update table, delete table by ipsi;
audit table, alter table by ipsi;

select * from dba_audit_trail;

SELECT username, timestamp, action_name FROM DBA_AUDIT_TRAIL;

select count(*) from sys.AUD$;


-- 현재 오라클 DB에서 사용중인 쿼리 조회
SELECT A.STATUS          -- 상태
       , A.USERNAME      -- 접속 계정명
       , A.SID           -- SID
       , A.SERIAL#       -- 시리얼번호
       , B.SQL_TEXT      -- 실행중인 쿼리 내용
  FROM V$SESSION A, V$SQLAREA B
 WHERE A.SQL_HASH_VALUE = B.HASH_VALUE
   AND A.SQL_ADDRESS = B.ADDRESS



SELECT P.spid,E.name as DBname,P.login_time, P.last_batch, P.status,P.program_name,P.cmd,P.loginame,C.client_net_address,D.text
FROM sys.sysprocesses AS P
INNER JOIN sys.dm_exec_connections AS C
ON P.spid = C.session_id
CROSS APPLY sys.dm_exec_sql_text (P . sql_handle) D
INNER JOIN sys.databases AS E
on D.dbid = E.database_id
-- WHERE client_net_address IN ('검색IP')
ORDER BY login_time




@$ORACLE_HOME/rdbms/admin/utlmail.sql
@$ORACLE_HOME/rdbms/admin/prvtmail.plb
ALTER SYSTEM SET smtp_out_server='smtp.gmail.com' SCOPE=BOTH;
SHUTDOWN IMMEDIATE
STARTUP

BEGIN
  UTL_MAIL.send(sender     => 'junxxzz@gmail.com',
                recipients => 'junxxzz@gmail.com',
                cc         => '',
                bcc        => '',
                subject    => 'UTL_MAIL Test',
                message    => 'If you get this message it worked!');
END;
/





create or replace function dump_csv(
    p_query in varchar2,
    p_separator in varchar2 default ',',
    p_dir in varchar2,
    p_filename in varchar2
)
return number
AUTHID CURRENT_USER
is
    l_output utl_file.file_type;
    l_theCursor integer default dbms_sql.open_cursor;
    l_columnValue varchar2(2000);
    l_status integer;
    l_colCnt number default 0;
    l_separator varchar2(10) default '';
    l_cnt number default 0;
begin
    l_output := utl_file.fopen( p_dir, p_filename, 'w' );

    dbms_sql.parse( l_theCursor, p_query, dbms_sql.native );

    for i in 1 .. 255 loop
        begin
            dbms_sql.define_column( l_theCursor, i, l_columnValue, 2000 );
            l_colCnt := i;
        exception
            when others then
                if ( sqlcode = -1007 ) then exit;
                else raise;
                end if;
            end;
    end loop;

    dbms_sql.define_column(l_theCursor, 1, l_columnValue, 2000);

    l_status := dbms_sql.execute(l_theCursor);

    loop
        exit when ( dbms_sql.fetch_rows(l_theCursor) <= 0 );
        l_separator := '';
        for i in 1 .. l_colCnt loop
            dbms_sql.column_value(l_theCursor, i, l_columnValue);
            utl_file.put(l_output, l_separator || l_columnValue);
            l_separator := p_separator;
        end loop;
        utl_file.new_line( l_output );
        l_cnt := l_cnt+1;
    end loop;
    dbms_sql.close_cursor(l_theCursor);

    utl_file.fclose( l_output );
    return l_cnt;
end dump_csv;
/






create or replace procedure test_dump_csv
as
l_rows number;
begin
    l_rows := dump_csv(
        'select * from temp1 where rownum < 25',
        ',',
        'DIR_TEMP',
        'test.dat' );
end;
/



BEGIN
  TEST_DUMP_CSV();
--rollback;
END;




docker run --name myoracle --hostname myoracle -itd -p 1521:1521 -p 5500:5500 -p 8080:8080 -e ORACLE_ENABLE_XDB=true -e ORACLE_ALLOW_REMOTE=true -e ORACLE_DISABLE_ASYNCH_IO=true -v D:\docker\uway1:/local andyrbell/oracle-xe-11g-centos

sqlplus / as sysdba

CREATE USER ipsi IDENTIFIED BY ipsi;
GRANT RESOURCE, CONNECT TO ipsi;

set echo off

ALTER SESSION SET SQL_TRACE = TRUE;

select * from ipsi.table1;

ALTER SESSION SET SQL_TRACE = FALSE;

quit

tkprof XE_ora_574.trc output




CREATE USER ORDSTEST IDENTIFIED BY ORDSTEST;
GRANT "CONNECT" TO ORDSTEST;
GRANT "RESOURCE" TO ORDSTEST;
GRANT UNLIMITED TABLESPACE TO ORDSTEST;

connect ORDSTEST/ORDSTEST

execute ORDS_ADMIN.ENABLE_SCHEMA


ords --config /u01/app/oracle/ords_conf install

select dbms_xdb.gethttpport() from dual;

begin
  DBMS_MACADM.AUTHORIZE_PROXY_USER('ORDS_PUBLIC_USER','ipsi');
end;
/



create or replace procedure procedure1
(
  param1 in number
) as
begin
    for temp in 1..param1
    loop
        insert into table1 values(temp);

        DBMS_OUTPUT.PUT_LINE(temp);

    end loop;
end procedure1;




GRANT CREATE ANY JOB TO ipsi;


-- no arguments

BEGIN
    DBMS_SCHEDULER.CREATE_JOB
    (
    JOB_NAME => 'EX_JOB',
    JOB_TYPE => 'STORED_PROCEDURE',
    JOB_ACTION => 'EX_PROC',
    REPEAT_INTERVAL => 'FREQ=MINUTELY; INTERVAL =1', --1분에 1번
    COMMENTS => '잡객체 1'
    );
END;

SELECT
*
FROM
USER_SCHEDULER_JOBS;



-- there is arguments

BEGIN
   DBMS_SCHEDULER.CREATE_PROGRAM (
       PROGRAM_NAME => 'procedure1_PROGRAM'
      ,PROGRAM_TYPE => 'STORED_PROCEDURE'
      ,PROGRAM_ACTION => 'procedure1'
      ,NUMBER_OF_ARGUMENTS => 1
      ,ENABLED => FALSE
      ,COMMENTS => 'procedure1 test');

   DBMS_SCHEDULER.DEFINE_PROGRAM_ARGUMENT (
       PROGRAM_NAME => 'procedure1_PROGRAM'
      ,ARGUMENT_POSITION => 1
      ,ARGUMENT_NAME => 'param1'
      ,ARGUMENT_TYPE => 'NUMBER'
      ,DEFAULT_VALUE => '10'
    );
   DBMS_SCHEDULER.ENABLE(NAME => 'procedure1_PROGRAM');
END;

SELECT
*
FROM
user_scheduler_programs;



BEGIN
DBMS_SCHEDULER.CREATE_SCHEDULE(
schedule_name => 'SCHEDULE_DAILY_AM_3_HOUR',
start_date       => TRUNC(SYSDATE)+1 +3/24,
end_date        => null,
repeat_interval => 'FREQ=DAILY;INTERVAL=1',
comments => 'Every AM 03 HOUR');
END;



BEGIN
DBMS_SCHEDULER.CREATE_SCHEDULE(
schedule_name => 'schedule_every_1_minutes',
start_date       => SYSDATE,
end_date        => null,
repeat_interval => 'FREQ=MINUTELY;INTERVAL=1',
comments => 'Every 1 minutes');
END;




select * from user_scheduler_schedules;




BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name =>'STATS_MAIN_BATCH_JOB',
program_name =>'STATS_MAIN_BATCH_PROGRAM',
schedule_name =>'SCHEDULE_DAILY_AM_3_HOUR',
comments => 'Service desk stats main batch program',
--job_class =>'SCHEDULER_JOB_CLASS',
enabled =>TRUE);
END;




BEGIN
DBMS_SCHEDULER.CREATE_JOB (
job_name =>'procedure1_JOB',
program_name =>'procedure1_PROGRAM',
schedule_name =>'schedule_every_1_minutes',
comments => 'Service desk stats main batch program',
--job_class =>'SCHEDULER_JOB_CLASS',
enabled =>TRUE);
END;



select * from user_scheduler_jobs;



select * from user_scheduler_job_log;



BEGIN

   DBMS_SCHEDULER.DROP_JOB(

        JOB_NAME   => 'STATS_MAIN_BATCH_JOB',

        FORCE      => FALSE);

END;



BEGIN

   DBMS_SCHEDULER.DROP_PROGRAM(

        PROGRAM_NAME   => 'STATS_MAIN_BATCH_PROGRAM',

        FORCE          => FALSE);

END;




REVOKE CREATE ANY JOB FROM ipsi;